Codd's 12 Rules, published in 1985 by Edgar F. Codd, define the strict criteria for a system to qualify as a true relational database management system (RDBMS).

Rule 0: Foundation Rule
The system must use its relational facilities exclusively to manage the database—no external tools or hacks.

Principle: Self-contained relational power.

Example: SQL alone defines tables, queries Loans JOIN Books, and enforces keys; no file-system bypass.
​

Rule 1: Information Rule

All information—data values, table names, column types—resides in tables; no other formats like files or hierarchies.

Principle: Uniform representation.

Example: Query INFORMATION_SCHEMA.COLUMNS to list Books' structure like any data table.
​

Rule 2: Guaranteed Access Rule

Every atomic value is accessible via table name + primary key + column name.

Principle: Predictable addressing without scans.

Example: SELECT title FROM Books WHERE id = 1 fetches exact value—no offsets or indices exposed.
​

Rule 3: Systematic Treatment of Null Values

Nulls represent missing/unknown data consistently, not blanks or specials; operations propagate them predictably.

Principle: Handle absence uniformly.

```text
| loan_id | book_id | borrower | return_date |
| ------- | ------- | -------- | ----------- |
| 1       | 101     | Alice    | NULL        |
| 2       | 102     | Bob      | 2026-01-10  |
```

Example: SELECT \* FROM Loans WHERE return_date IS NULL finds overdue books safely.
​

Rule 4, the Active Online Catalog Rule, requires that the database's metadata (like table names, column types, constraints) lives in queryable tables just like your regular data. No special commands—treat schema info as regular relations you can SELECT from using standard SQL.

Simple Example - Library Database:

Regular Data Tables:

```sql

Books: id | title
        1  | Hobbit

Authors: id | name
           1  | Tolkien

```

Metadata as Data (Catalog Tables):

The DBMS stores schema info in tables like INFORMATION_SCHEMA.TABLES:

```sql
TABLE_NAME | TABLE_TYPE
Books      | BASE TABLE
Authors    | BASE TABLE
```

Query the Catalog (Rule 4):

```sql

SELECT table_name
FROM INFORMATION_SCHEMA.TABLES
WHERE table_type = 'BASE TABLE';
```

### A base table stores your actual persistent data—the real tables you create with CREATE TABLE where rows get inserted, updated, and deleted. Think of it as the "source of truth" holding the raw facts

```sql
Other Table Types (from INFORMATION_SCHEMA.TABLES):

text
TABLE_NAME    | TABLE_TYPE
--------------|------------
Books         | BASE TABLE    ← Your data lives here
TolkienBooks  | VIEW          ← Virtual table from query
temp_loans    | LOCAL TEMPORARY  ← Session-only, auto-deletes
summary_sales | MATERIALIZED VIEW  ← Cached query results (PostgreSQL)
```

```sql
Simple Example - Query All Types:

sql
SELECT table_name, table_type
FROM INFORMATION_SCHEMA.TABLES
WHERE table_schema = 'public';
```

​Why This Matters:

Uniformity: Same SQL works on data and metadata—no special APIs

Dynamic Apps: Build tools that discover tables/columns at runtime

First Principle: Metadata is data, following relational purity

```sql
Real-World Use:
List all columns in Books table:

sql
SELECT column_name, data_type
FROM INFORMATION_SCHEMA.COLUMNS
WHERE table_name = 'Books';
text
column_name | data_type
id          | INTEGER
title       | VARCHAR
```

Rule 5, the Comprehensive Data Sublanguage Rule, requires one single language (like SQL) to handle everything in the database: creating tables, inserting data, defining views, enforcing security, managing transactions, and more. No switching tools—SQL does it all uniformly.

Simple Example - Complete Library Workflow in Pure SQL:

```sql
-- 1. Define structure (DDL)
CREATE TABLE Authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE Books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INT REFERENCES Authors(id)
);

-- 2. Insert data (DML)
INSERT INTO Authors (name) VALUES ('Tolkien');
INSERT INTO Books (title, author_id) VALUES ('Hobbit', 1);

-- 3. Create views
CREATE VIEW TolkienBooks AS
SELECT b.title, a.name
FROM Books b JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

-- 4. Manage security (Authorization)
GRANT SELECT ON Books TO public;
GRANT INSERT, UPDATE ON Books TO librarian;
REVOKE DELETE ON Books FROM public;

-- 5. Transactions (ACID)
BEGIN;
UPDATE Books SET title = 'There and Back Again' WHERE id = 1;
-- Simulate error: ROLLBACK;  (or COMMIT;)
COMMIT;

-- 6. Integrity constraints
ALTER TABLE Books ADD CONSTRAINT unique_title UNIQUE(title);

Why This Matters:

Unified Interface: One language = one mental model, no tool sprawl

Portability: SQL works across PostgreSQL, MySQL, SQLite, Oracle

First Principle: Relational operations expressed declaratively

```

Rule 6, the View Updating Rule, states that any view (virtual table from a query) that could theoretically be updated must fully support INSERT, UPDATE, and DELETE operations exactly like a real base table. This ensures views provide transparent abstraction—you interact with them seamlessly without knowing they're derived from other tables.

Think of a view as a filtered window over your data. A simple example starts with base tables:

```sql
Authors: id | name
          1  | Tolkien

Books: id | title          | author_id
        1  | Hobbit         | 1
        2  | Lord of Rings  | 1


CREATE VIEW TolkienBooks AS
SELECT b.id, b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

OUTPUT:
id | title          | name
 1 | Hobbit         | Tolkien
 2 | Lord of Rings  | Tolkien

update:
INSERT INTO TolkienBooks (title, name) VALUES ('Silmarillion', 'Tolkien');

Books now:
id | title          | author_id
 1 | Hobbit         | 1
 2 | Lord of Rings  | 1
 3 | Silmarillion   | 1  ← Added via view!


```

​

Rule 7, the High-Level Insert, Update, and Delete Rule, requires that these operations work on entire sets of rows at once, not one record at a time through loops. This follows relational algebra principles where tables are mathematical sets—you declare what changes (via predicates), and the DBMS figures out how efficiently.

Simple Example - Loans Library System:

```sql
Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | borrowed  | 2026-01-05
         3 | 103     | borrowed  | 2026-01-06
         4 | 104     | borrowed  | NULL

Set-Based UPDATE (Rule 7):

UPDATE Loans
SET status = 'returned'
WHERE return_date IS NOT NULL;

output: After (batches 2 rows at once):


Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | returned  | 2026-01-05  ← Changed
         3 | 103     | returned  | 2026-01-06  ← Changed
         4 | 104     | borrowed  | NULL

Contrast with "Record-at-a-Time" (violates Rule 7):

sql
-- BAD: Procedural loop (not relational)
FOR each loan WHERE return_date IS NOT NULL:
    UPDATE Loans SET status = 'returned' WHERE id = loan.id;

```

​

Rule 8: Physical Data Independence
Changes to storage (files, indexes, disks) do not affect application queries.
Principle: Logical ops hide hardware.
Example: Optimizer swaps B-tree for hash index on author_id; JOIN query unchanged.
​

Rule 9: Logical Data Independence
Schema changes (add/remove columns, split tables) preserve external views.
Principle: Stable interfaces.
Example: Add isbn to Books; old SELECT title FROM Books views unaffected via mapping.
​

Rule 10: Integrity Independence
All constraints (primary/foreign keys, check rules) are stored in the catalog and enforced by the DBMS.
Principle: Centralized rules.
Example: ALTER TABLE Books ADD CONSTRAINT fk_author FOREIGN KEY (author_id) REFERENCES Authors(id);—auto-checked, no app code.
​

Rule 11: Distribution Independence
Users see unified data whether centralized or sharded across servers.
Principle: Transparent scale.
Example: SELECT \* FROM Loans JOIN Books works if Loans on server A, Books on B.
​

Rule 12: Nonsubversion Rule
Low-level interfaces (if any) cannot bypass higher-level relational constraints.
Principle: No integrity leaks.
Example: Even record-level APIs enforce NOT NULL on primary keys—no raw writes allowed.
​

Why These Rules Matter
Few commercial RDBMS fully comply (e.g., view updating is hard), but they guide design for reliability and portability. In Rust, libraries like Diesel enforce these via type-safe queries, mirroring Codd's purity for top-tier systems. Build relations from sets: every table a predicate, rows its truths.
