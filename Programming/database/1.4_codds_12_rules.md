Codd's 12 Rules, published in 1985 by Edgar F. Codd, define the strict criteria for a system to qualify as a true relational database management system (RDBMS).

Rule 0: Foundation Rule
The system must use its relational facilities exclusively to manage the database‚Äîno external tools or hacks.

Principle: Self-contained relational power.

Example: SQL alone defines tables, queries Loans JOIN Books, and enforces keys; no file-system bypass.
‚Äã

Rule 1: Information Rule

All information‚Äîdata values, table names, column types‚Äîresides in tables; no other formats like files or hierarchies.

Principle: Uniform representation.

Example: Query INFORMATION_SCHEMA.COLUMNS to list Books' structure like any data table.
‚Äã

Rule 2: Guaranteed Access Rule

Every atomic value is accessible via table name + primary key + column name.

Principle: Predictable addressing without scans.

Example: SELECT title FROM Books WHERE id = 1 fetches exact value‚Äîno offsets or indices exposed.
‚Äã

Rule 3: Systematic Treatment of Null Values

Nulls represent missing/unknown data consistently, not blanks or specials; operations propagate them predictably.

Principle: Handle absence uniformly.

```text
| loan_id | book_id | borrower | return_date |
| ------- | ------- | -------- | ----------- |
| 1       | 101     | Alice    | NULL        |
| 2       | 102     | Bob      | 2026-01-10  |
```

Example: SELECT \* FROM Loans WHERE return_date IS NULL finds overdue books safely.
‚Äã

Rule 4, the Active Online Catalog Rule, requires that the database's metadata (like table names, column types, constraints) lives in queryable tables just like your regular data. No special commands‚Äîtreat schema info as regular relations you can SELECT from using standard SQL.

Simple Example - Library Database:

Regular Data Tables:

```sql

Books: id | title
        1  | Hobbit

Authors: id | name
           1  | Tolkien

```

Metadata as Data (Catalog Tables):

The DBMS stores schema info in tables like INFORMATION_SCHEMA.TABLES:

```sql
TABLE_NAME | TABLE_TYPE
Books      | BASE TABLE
Authors    | BASE TABLE
```

Query the Catalog (Rule 4):

```sql

SELECT table_name
FROM INFORMATION_SCHEMA.TABLES
WHERE table_type = 'BASE TABLE';
```

### A base table stores your actual persistent data‚Äîthe real tables you create with CREATE TABLE where rows get inserted, updated, and deleted. Think of it as the "source of truth" holding the raw facts

```sql
Other Table Types (from INFORMATION_SCHEMA.TABLES):

text
TABLE_NAME    | TABLE_TYPE
--------------|------------
Books         | BASE TABLE    ‚Üê Your data lives here
TolkienBooks  | VIEW          ‚Üê Virtual table from query
temp_loans    | LOCAL TEMPORARY  ‚Üê Session-only, auto-deletes
summary_sales | MATERIALIZED VIEW  ‚Üê Cached query results (PostgreSQL)
```

```sql
Simple Example - Query All Types:

sql
SELECT table_name, table_type
FROM INFORMATION_SCHEMA.TABLES
WHERE table_schema = 'public';
```

‚ÄãWhy This Matters:

Uniformity: Same SQL works on data and metadata‚Äîno special APIs

Dynamic Apps: Build tools that discover tables/columns at runtime

First Principle: Metadata is data, following relational purity

```sql
Real-World Use:
List all columns in Books table:

sql
SELECT column_name, data_type
FROM INFORMATION_SCHEMA.COLUMNS
WHERE table_name = 'Books';
text
column_name | data_type
id          | INTEGER
title       | VARCHAR
```

Rule 5, the Comprehensive Data Sublanguage Rule, requires one single language (like SQL) to handle everything in the database: creating tables, inserting data, defining views, enforcing security, managing transactions, and more. No switching tools‚ÄîSQL does it all uniformly.

Simple Example - Complete Library Workflow in Pure SQL:

```sql
-- 1. Define structure (DDL)
CREATE TABLE Authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE Books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INT REFERENCES Authors(id)
);

-- 2. Insert data (DML)
INSERT INTO Authors (name) VALUES ('Tolkien');
INSERT INTO Books (title, author_id) VALUES ('Hobbit', 1);

-- 3. Create views
CREATE VIEW TolkienBooks AS
SELECT b.title, a.name
FROM Books b JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

-- 4. Manage security (Authorization)
GRANT SELECT ON Books TO public;
GRANT INSERT, UPDATE ON Books TO librarian;
REVOKE DELETE ON Books FROM public;

-- 5. Transactions (ACID)
BEGIN;
UPDATE Books SET title = 'There and Back Again' WHERE id = 1;
-- Simulate error: ROLLBACK;  (or COMMIT;)
COMMIT;

-- 6. Integrity constraints
ALTER TABLE Books ADD CONSTRAINT unique_title UNIQUE(title);

Why This Matters:

Unified Interface: One language = one mental model, no tool sprawl

Portability: SQL works across PostgreSQL, MySQL, SQLite, Oracle

First Principle: Relational operations expressed declaratively

```

Rule 6, the View Updating Rule, states that any view (virtual table from a query) that could theoretically be updated must fully support INSERT, UPDATE, and DELETE operations exactly like a real base table. This ensures views provide transparent abstraction‚Äîyou interact with them seamlessly without knowing they're derived from other tables.

Think of a view as a filtered window over your data. A simple example starts with base tables:

```sql
Authors: id | name
          1  | Tolkien

Books: id | title          | author_id
        1  | Hobbit         | 1
        2  | Lord of Rings  | 1


CREATE VIEW TolkienBooks AS
SELECT b.id, b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

OUTPUT:
id | title          | name
 1 | Hobbit         | Tolkien
 2 | Lord of Rings  | Tolkien

update:
INSERT INTO TolkienBooks (title, name) VALUES ('Silmarillion', 'Tolkien');

Books now:
id | title          | author_id
 1 | Hobbit         | 1
 2 | Lord of Rings  | 1
 3 | Silmarillion   | 1  ‚Üê Added via view!


```

‚Äã

Rule 7, the High-Level Insert, Update, and Delete Rule, requires that these operations work on entire sets of rows at once, not one record at a time through loops. This follows relational algebra principles where tables are mathematical sets‚Äîyou declare what changes (via predicates), and the DBMS figures out how efficiently.

Simple Example - Loans Library System:

```sql
Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | borrowed  | 2026-01-05
         3 | 103     | borrowed  | 2026-01-06
         4 | 104     | borrowed  | NULL

Set-Based UPDATE (Rule 7):

UPDATE Loans
SET status = 'returned'
WHERE return_date IS NOT NULL;

output: After (batches 2 rows at once):


Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | returned  | 2026-01-05  ‚Üê Changed
         3 | 103     | returned  | 2026-01-06  ‚Üê Changed
         4 | 104     | borrowed  | NULL

Contrast with "Record-at-a-Time" (violates Rule 7):

sql
-- BAD: Procedural loop (not relational)
FOR each loan WHERE return_date IS NOT NULL:
    UPDATE Loans SET status = 'returned' WHERE id = loan.id;

```

‚Äã

Rule 8:

### Your Queries Don't Care About Storage

the Physical Data Independence Rule, means your SQL queries work identically no matter how the database stores data physically (files, disks, indexes, compression). The query optimizer hides all hardware details‚Äîyou write logical "what," DBMS handles physical "how."

Simple Example - Library JOIN Query:

```sql
Your app says: "Give me books by Tolkien"
üìö‚Üê Your simple SQL query

Database chef says: "OK, let me grab that using..."
üç≥ Storage cupboard #1 (slow old fridge) ‚Üí 5 seconds
üç≥ Storage cupboard #2 (fast new pantry) ‚Üí 1 second
üç≥ Storage cupboard #3 (magic drawer) ‚Üí 0.5 seconds

You get: üìö Tolkien books (same result every time)

Your App Query (Never Changes):

sql
SELECT b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id;

```

Rule 9, the Logical Data Independence Rule, means your apps and views keep working perfectly even when the database admins change the table structure underneath (add columns, split tables, rename stuff). Your external "windows" into the data stay stable.
‚Äã

```sql
Library Example:

Your App Query (Never Changes):

sql
-- Your simple view/app
SELECT title FROM Books;
-- Returns: "Hobbit", "Lord of Rings"
DBA Makes Schema Changes (You Notice Nothing):

sql
-- They add columns, split tables behind scenes
ALTER TABLE Books ADD isbn VARCHAR, pages INT;
-- Or even: CREATE TABLE BookDetails... (splits data)
After Changes:

text
Books now secretly: title | isbn     | pages
                   Hobbit | 123456   | 300
text
Your Query Still Returns: "Hobbit" ‚úÖ Unchanged!
Real Changes That Dont Break You:

Add isbn, pages, published_date columns

Split Books into Books + BookMetadata

Rename author_id ‚Üí author_uuid internally

Merge Authors + Books into one big LibraryItems

Your View/App: "SELECT title FROM Books" ‚Üí Same results forever.

------------
Your app queries a *stable VIEW* (not raw table):
CREATE VIEW BooksView AS SELECT title, author_id FROM Books;
SELECT author_id FROM BooksView;  ‚úÖ Works forever

DBA renames column internally:
ALTER TABLE Books RENAME author_id TO author_uuid;
ALTER VIEW BooksView AS SELECT title, author_id AS author_id FROM Books;

Your app: SELECT author_id FROM BooksView;  ‚úÖ Still works!


```

Rule 10: Integrity Independence
All constraints (primary/foreign keys, check rules) are stored in the catalog and enforced by the DBMS.
Principle: Centralized rules.
Example: ALTER TABLE Books ADD CONSTRAINT fk_author FOREIGN KEY (author_id) REFERENCES Authors(id);‚Äîauto-checked, no app code.
‚Äã

Rule 11: Distribution Independence
Users see unified data whether centralized or sharded across servers.
Principle: Transparent scale.
Example: SELECT \* FROM Loans JOIN Books works if Loans on server A, Books on B.
‚Äã

Rule 12: Nonsubversion Rule
Low-level interfaces (if any) cannot bypass higher-level relational constraints.
Principle: No integrity leaks.
Example: Even record-level APIs enforce NOT NULL on primary keys‚Äîno raw writes allowed.
‚Äã

Why These Rules Matter
Few commercial RDBMS fully comply (e.g., view updating is hard), but they guide design for reliability and portability. In Rust, libraries like Diesel enforce these via type-safe queries, mirroring Codd's purity for top-tier systems. Build relations from sets: every table a predicate, rows its truths.
