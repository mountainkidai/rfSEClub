Codd's 12 Rules, published in 1985 by Edgar F. Codd, define the strict criteria for a system to qualify as a true relational database management system (RDBMS).

Rule 0: Foundation Rule
The system must use its relational facilities exclusively to manage the database‚Äîno external tools or hacks.

Principle: Self-contained relational power.

Example: SQL alone defines tables, queries Loans JOIN Books, and enforces keys; no file-system bypass.
‚Äã

Rule 1: Information Rule

All information‚Äîdata values, table names, column types‚Äîresides in tables; no other formats like files or hierarchies.

Principle: Uniform representation.

Example: Query INFORMATION_SCHEMA.COLUMNS to list Books' structure like any data table.
‚Äã

Rule 2: Guaranteed Access Rule

Every atomic value is accessible via table name + primary key + column name.

Principle: Predictable addressing without scans.

Example: SELECT title FROM Books WHERE id = 1 fetches exact value‚Äîno offsets or indices exposed.
‚Äã

Rule 3: Systematic Treatment of Null Values

Nulls represent missing/unknown data consistently, not blanks or specials; operations propagate them predictably.

Principle: Handle absence uniformly.

```text
| loan_id | book_id | borrower | return_date |
| ------- | ------- | -------- | ----------- |
| 1       | 101     | Alice    | NULL        |
| 2       | 102     | Bob      | 2026-01-10  |
```

Example: SELECT \* FROM Loans WHERE return_date IS NULL finds overdue books safely.
‚Äã

Rule 4, the Active Online Catalog Rule, requires that the database's metadata (like table names, column types, constraints) lives in queryable tables just like your regular data. No special commands‚Äîtreat schema info as regular relations you can SELECT from using standard SQL.

Simple Example - Library Database:

Regular Data Tables:

```sql

Books: id | title
        1  | Hobbit

Authors: id | name
           1  | Tolkien

```

Metadata as Data (Catalog Tables):

The DBMS stores schema info in tables like INFORMATION_SCHEMA.TABLES:

```sql
TABLE_NAME | TABLE_TYPE
Books      | BASE TABLE
Authors    | BASE TABLE
```

Query the Catalog (Rule 4):

```sql

SELECT table_name
FROM INFORMATION_SCHEMA.TABLES
WHERE table_type = 'BASE TABLE';
```

### A base table stores your actual persistent data‚Äîthe real tables you create with CREATE TABLE where rows get inserted, updated, and deleted. Think of it as the "source of truth" holding the raw facts

```sql
Other Table Types (from INFORMATION_SCHEMA.TABLES):

text
TABLE_NAME    | TABLE_TYPE
--------------|------------
Books         | BASE TABLE    ‚Üê Your data lives here
TolkienBooks  | VIEW          ‚Üê Virtual table from query
temp_loans    | LOCAL TEMPORARY  ‚Üê Session-only, auto-deletes
summary_sales | MATERIALIZED VIEW  ‚Üê Cached query results (PostgreSQL)
```

```sql
Simple Example - Query All Types:

sql
SELECT table_name, table_type
FROM INFORMATION_SCHEMA.TABLES
WHERE table_schema = 'public';
```

‚ÄãWhy This Matters:

Uniformity: Same SQL works on data and metadata‚Äîno special APIs

Dynamic Apps: Build tools that discover tables/columns at runtime

First Principle: Metadata is data, following relational purity

```sql
Real-World Use:
List all columns in Books table:

sql
SELECT column_name, data_type
FROM INFORMATION_SCHEMA.COLUMNS
WHERE table_name = 'Books';
text
column_name | data_type
id          | INTEGER
title       | VARCHAR
```

Rule 5, the Comprehensive Data Sublanguage Rule, requires one single language (like SQL) to handle everything in the database: creating tables, inserting data, defining views, enforcing security, managing transactions, and more. No switching tools‚ÄîSQL does it all uniformly.

Simple Example - Complete Library Workflow in Pure SQL:

```sql
-- 1. Define structure (DDL)
CREATE TABLE Authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE Books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INT REFERENCES Authors(id)
);

-- 2. Insert data (DML)
INSERT INTO Authors (name) VALUES ('Tolkien');
INSERT INTO Books (title, author_id) VALUES ('Hobbit', 1);

-- 3. Create views
CREATE VIEW TolkienBooks AS
SELECT b.title, a.name
FROM Books b JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

-- 4. Manage security (Authorization)
GRANT SELECT ON Books TO public;
GRANT INSERT, UPDATE ON Books TO librarian;
REVOKE DELETE ON Books FROM public;

-- 5. Transactions (ACID)
BEGIN;
UPDATE Books SET title = 'There and Back Again' WHERE id = 1;
-- Simulate error: ROLLBACK;  (or COMMIT;)
COMMIT;

-- 6. Integrity constraints
ALTER TABLE Books ADD CONSTRAINT unique_title UNIQUE(title);

Why This Matters:

Unified Interface: One language = one mental model, no tool sprawl

Portability: SQL works across PostgreSQL, MySQL, SQLite, Oracle

First Principle: Relational operations expressed declaratively

```

Rule 6, the View Updating Rule, states that any view (virtual table from a query) that could theoretically be updated must fully support INSERT, UPDATE, and DELETE operations exactly like a real base table. This ensures views provide transparent abstraction‚Äîyou interact with them seamlessly without knowing they're derived from other tables.

Think of a view as a filtered window over your data. A simple example starts with base tables:

```sql
Authors: id | name
          1  | Tolkien

Books: id | title          | author_id
        1  | Hobbit         | 1
        2  | Lord of Rings  | 1


CREATE VIEW TolkienBooks AS
SELECT b.id, b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id
WHERE a.name = 'Tolkien';

OUTPUT:
id | title          | name
 1 | Hobbit         | Tolkien
 2 | Lord of Rings  | Tolkien

update:
INSERT INTO TolkienBooks (title, name) VALUES ('Silmarillion', 'Tolkien');

Books now:
id | title          | author_id
 1 | Hobbit         | 1
 2 | Lord of Rings  | 1
 3 | Silmarillion   | 1  ‚Üê Added via view!


```

‚Äã

Rule 7, the High-Level Insert, Update, and Delete Rule, requires that these operations work on entire sets of rows at once, not one record at a time through loops. This follows relational algebra principles where tables are mathematical sets‚Äîyou declare what changes (via predicates), and the DBMS figures out how efficiently.

Simple Example - Loans Library System:

```sql
Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | borrowed  | 2026-01-05
         3 | 103     | borrowed  | 2026-01-06
         4 | 104     | borrowed  | NULL

Set-Based UPDATE (Rule 7):

UPDATE Loans
SET status = 'returned'
WHERE return_date IS NOT NULL;

output: After (batches 2 rows at once):


Loans: id | book_id | status    | return_date
         1 | 101     | borrowed  | NULL
         2 | 102     | returned  | 2026-01-05  ‚Üê Changed
         3 | 103     | returned  | 2026-01-06  ‚Üê Changed
         4 | 104     | borrowed  | NULL

Contrast with "Record-at-a-Time" (violates Rule 7):

sql
-- BAD: Procedural loop (not relational)
FOR each loan WHERE return_date IS NOT NULL:
    UPDATE Loans SET status = 'returned' WHERE id = loan.id;

```

‚Äã

Rule 8:

### Your Queries Don't Care About Storage

the Physical Data Independence Rule, means your SQL queries work identically no matter how the database stores data physically (files, disks, indexes, compression). The query optimizer hides all hardware details‚Äîyou write logical "what," DBMS handles physical "how."

Simple Example - Library JOIN Query:

```sql
Your app says: "Give me books by Tolkien"
üìö‚Üê Your simple SQL query

Database chef says: "OK, let me grab that using..."
üç≥ Storage cupboard #1 (slow old fridge) ‚Üí 5 seconds
üç≥ Storage cupboard #2 (fast new pantry) ‚Üí 1 second
üç≥ Storage cupboard #3 (magic drawer) ‚Üí 0.5 seconds

You get: üìö Tolkien books (same result every time)

Your App Query (Never Changes):

sql
SELECT b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id;

```

Rule 9, the Logical Data Independence Rule, means your apps and views keep working perfectly even when the database admins change the table structure underneath (add columns, split tables, rename stuff). Your external "windows" into the data stay stable.
‚Äã

```sql
Library Example:

Your App Query (Never Changes):

sql
-- Your simple view/app
SELECT title FROM Books;
-- Returns: "Hobbit", "Lord of Rings"
DBA Makes Schema Changes (You Notice Nothing):

sql
-- They add columns, split tables behind scenes
ALTER TABLE Books ADD isbn VARCHAR, pages INT;
-- Or even: CREATE TABLE BookDetails... (splits data)
After Changes:

text
Books now secretly: title | isbn     | pages
                   Hobbit | 123456   | 300
text
Your Query Still Returns: "Hobbit" ‚úÖ Unchanged!
Real Changes That Dont Break You:

Add isbn, pages, published_date columns

Split Books into Books + BookMetadata

Rename author_id ‚Üí author_uuid internally

Merge Authors + Books into one big LibraryItems

Your View/App: "SELECT title FROM Books" ‚Üí Same results forever.

------------
Your app queries a *stable VIEW* (not raw table):
CREATE VIEW BooksView AS SELECT title, author_id FROM Books;
SELECT author_id FROM BooksView;  ‚úÖ Works forever

DBA renames column internally:
ALTER TABLE Books RENAME author_id TO author_uuid;
ALTER VIEW BooksView AS SELECT title, author_id AS author_id FROM Books;

Your app: SELECT author_id FROM BooksView;  ‚úÖ Still works!


```

Rule 10, the Integrity Independence Rule, means all data rules (like "no empty IDs", "authors must exist", "age > 0") live inside the database catalog, not scattered in app code. The DBMS automatically enforces them on every operation.
‚Äã

```sql

CREATE TABLE Authors (
    id SERIAL PRIMARY KEY,        -- DBMS: "ID never empty"
    name VARCHAR(100) NOT NULL    -- DBMS: "Name required"
);

CREATE TABLE Books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INT,
    pages INT CHECK (pages > 0)   -- DBMS: "Pages must be positive"
    FOREIGN KEY (author_id) REFERENCES Authors(id)  -- "Author must exist"
);

OUTPUT:
-- These AUTOMATICALLY FAIL (no app code needed):
INSERT INTO Books (title, author_id, pages) VALUES ('Hobbit', NULL, -5);
-- ‚ùå "NULL violates NOT NULL" + "negative pages" + "missing author"

INSERT INTO Books (title, author_id) VALUES ('Hobbit', 999);
-- ‚ùå "Author 999 doesn't exist"

INSERT INTO Authors (name) VALUES ('Tolkien');
INSERT INTO Books (title, author_id, pages) VALUES ('Hobbit', 1, 310);
‚úÖ Success!


```

Rule 11, the Distribution Independence Rule, means your SQL queries work identically whether all data lives on one computer or is spread across 100 servers worldwide. You never see the complexity‚Äîthe database glues it together transparently.

```sql
SELECT b.title, a.name
FROM Books b
JOIN Authors a ON b.author_id = a.id;
```

Behind the Scenes (Transparent to You):

```sql
üöÄ Scenario 1: Single Laptop
Books table + Authors table = 1 machine ‚úÖ

üåç Scenario 2: Global Scale (You notice NOTHING)
Books table ‚Üí Server in India
Authors table ‚Üí Server in USA
JOIN happens magically across internet ‚úÖ

üó∫Ô∏è Scenario 3: Sharded Chaos
Books shard 1 ‚Üí Server A (IDs 1-1000)
Books shard 2 ‚Üí Server B (IDs 1001-2000)
Authors ‚Üí Server C (cloud)
Your JOIN still works perfectly ‚úÖ
```

### Shard = Splitting a giant table across multiple computers

```sql
‚ùå ONE Giant Books Table (1 computer = SLOW)
Books: 1B rows = 1TB data ‚Üí One laptop CRASHES!

‚úÖ SHARDED Books Table (10 computers = FAST)
Shard 1 (Server A): Books ID 1-100M
Shard 2 (Server B): Books ID 101M-200M
Shard 3 (Server C): Books ID 201M-300M
... (10 servers total)
Your Query SELECT * FROM Books WHERE id = 12345678

Rule 11 Magic: "Go to Shard 2 (Server B), row 2345678"
You see: One unified Books table ‚ú®

Real Example - Instagram Scale:

1B users ‚Üí Cant fit one server!

Instagram shards by USER_ID:
- Shard 1: Users A-M ‚Üí Server USA-West
- Shard 2: Users N-Z ‚Üí Server Europe
- Shard 3: New users ‚Üí Server Asia

Your SQL: SELECT posts FROM Users WHERE user_id = 'john_doe'
Behind scenes: Routes to Shard 1 automatically.

üî• Without sharding: 1 server = 10K users max
üöÄ With sharding: 100 shards = 1M users easy
```

Rule 12, the Nonsubversion Rule, means no back doors exist‚Äîeven if the database offers low-level "record-by-record" APIs, they cannot bypass relational rules, constraints, or set operations. Everything stays pure relational.

```sql
Simple Analogy - Bank Vault:

‚úÖ Normal Door (SQL): "Transfer $100 from A to B"
   Bank checks: Balance ‚â• $100, valid accounts, etc.

‚úÖ Secret Back Door (Raw API): "Transfer $100 from A to B"
   Bank STILL checks: Balance ‚â• $100, valid accounts, etc.

Library Example:

Normal SQL (Set-based, Rule 7 compliant):

INSERT INTO Books (title, author_id) VALUES ('Hobbit', 1);  ‚úÖ
-- DB checks: author_id=1 exists, title not null, etc.

What Gets Blocked Everywhere:

‚ùå Duplicate primary keys
‚ùå NULL in NOT NULL columns
‚ùå Invalid foreign keys
‚ùå Negative pages (CHECK constraint)
‚ùå Record-at-a-time loops (must use set operations)

```

### 4 Core Set Operations:

```sql
1. UNION (Merge, remove duplicates)
   Books_2024 UNION Books_2025 = ALL unique books

2. UNION ALL (Merge, keep duplicates)
   Books_2024 UNION ALL Books_2025 = Everything

3. INTERSECT (Common items only)
   FantasyBooks INTERSECT SciFiBooks = Sci-Fi Fantasy books

4. EXCEPT/MINUS (First minus second)
   FantasyBooks EXCEPT SciFiBooks = Pure fantasy only
```

### Library

```sql
üìö FantasyBooks:  ["Hobbit", "Narnia", "LOTR"]
üöÄ SciFiBooks:    ["Dune", "LOTR", "Foundation"]

Fantasy UNION SciFi              = ["Hobbit", "Narnia", "LOTR", "Dune", "Foundation"]     ‚Üê No duplicates
Fantasy UNION ALL SciFi           = ["Hobbit", "Narnia", "LOTR", "Dune", "LOTR", "Foundation"]  ‚Üê KEEP duplicates
Fantasy INTERSECT SciFi           = ["LOTR"]                                                       ‚Üê Only common!
Fantasy EXCEPT SciFi (MINUS)     = ["Hobbit", "Narnia"]                                          ‚Üê Fantasy ONLY!
SciFi EXCEPT Fantasy              = ["Dune", "Foundation"]                                        ‚Üê SciFi ONLY!

```
